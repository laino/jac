
const PRECISION = 15;
const PRECISION_N = Math.pow(10, PRECISION);;

export function round(num: number): number {
    if (num === 0) {
        return 0;
    }

    if (num > PRECISION_N) {
        return Math.round(num);
    }

    const abs = Math.abs(num);

    let m = PRECISION - 1;

    if (abs > 1) {
        m -= Math.floor(Math.log10(abs));
    }

    const n = Math.pow(10, m);

    return Math.round(num * n + Number.EPSILON) / n;
}

export type NumberArrayLike = Float64Array | number[];
export type Point = Float64Array;

export interface PointWeight {
    P: Point,
    w: number
}

export interface CloudSettings {
    maxPoints: number
}

export type Selection = Map<Point, number>;

export type DimensionCompare = (a: number, b: number) => number;

function PointWeight(P: Point, w: number) {
    return {P, w};
}

function nCompare(cloud: Cloud, n: number): DimensionCompare {
    const points = cloud.points;

    return (a: number, b: number) => {
        const A = points[a];
        const B = points[b];

        const dDiff = B[n] - A[n];

        if (dDiff !== 0) {
            return dDiff;
        }
    };
}

function fullCompare(cloud: Cloud) {
    const points = cloud.points;

    return (a: number, b: number) => {
        const A = points[a];
        const B = points[b];

        for (let i = 1; i < cloud.dimensions; i++) {
            const dDiff = B[i] - A[i];

            if (dDiff !== 0) {
                return dDiff;
            }
        }

        return 0;
    };
}

export interface SortTreeNode {
    index: number,
    parent: SortTreeNode,
    left: SortTreeNode,
    right: SortTreeNode
}

function SortTreeNode(index: number): SortTreeNode {
    return {
        index,
        parent: null,
        left: null,
        right: null,
    };
}

export class SortTree {
    public root: SortTreeNode;
    public map: SortTreeNode[];

    public constructor(private cloud: Cloud, private compare: DimensionCompare) {
        this.map = [];

        for (let i = 0; i < cloud.settings.maxPoints; i++) {
            this.map.push(SortTreeNode(i));
        }
    }
    
    public update(i: number) {
        const node = this.map[i];

        this.unlinkNode(node);
        this.insertNode(node);
    }
    
    public remove(i: number) {
        const node = this.map[i];

        this.unlinkNode(node);
    }

    private insertNode(node: SortTreeNode) {
        if (!this.root) {
            this.root = node;
            return;
        }

        this.insert(this.root, node);    
    }

    private unlinkNode(node: SortTreeNode) {
        if (node === this.root) {
            if (node.right) {
                this.root = node.right;

                if (node.left) {
                    this.insert(this.root, node.left);
                }
            } else {
                this.root = node.left;
            }

            node.left = null;
            node.right = null;

            return;
        }

        const parent = node.parent;

        if (!parent) {
            return;
        }

        if (parent.left === node) {
            if (node.left) {
                parent.left = node.left;
                node.left.parent = parent;

                if (node.right) {
                    this.insert(parent.left, node.right);
                }
            } else if (node.right) {
                parent.left = node.right;
                node.right.parent = parent;
            } else {
                parent.left = null;
            }
        } else {
            if (node.right) {
                parent.right = node.right;
                node.right.parent = parent;

                if (node.left) {
                    this.insert(parent.right, node.left);
                }
            } else if (node.left) {
                parent.right = node.left;
                node.left.parent = parent;
            } else {
                parent.right = null;
            }
        }

        node.left = null;
        node.right = null;
        node.parent = null;
    }

    public findNode(condition: (node: SortTreeNode) => number): SortTreeNode {
        let node = this.root;

        while (node) {
            const side = condition(node);
            
            if (side === 0) {
                return node;
            }

            if (side < 0) {
                node = node.left;
            } else {
                node = node.right;
            }     
        }

        return null;
    }

    private insert(parent: SortTreeNode, node: SortTreeNode) {
        while (true) {
            const side = this.compare(parent.index, node.index);

            if (side <= 0) {
                if (!parent.left) {
                    parent.left = node;
                    node.parent = parent;
                    return;
                }

                parent = parent.left;
            } else {
                if (!parent.right) {
                    parent.right = node;
                    node.parent = parent;
                    return;
                }

                parent = parent.right;
            }
        }
    }

    public iterateRight(node: SortTreeNode, iter: (node: SortTreeNode) => boolean) {
        while (node && iter(node) !== false) {
            node = this.rightOf(node);
        }

        return node;
    }
    
    public iterateLeft(node: SortTreeNode, iter: (node: SortTreeNode) => boolean) {
        while (node && iter(node) !== false) {
            node = this.leftOf(node);
        }

        return node;
    }

    public rightOf(node: SortTreeNode): SortTreeNode {
        if (node.right) {
            node = node.right;

            while (node.left) {
                node = node.left;
            }
        } else {
            let parent: SortTreeNode;

            while ((parent = node.parent) && parent.right === node) {
                node = parent;
            }

            node = parent;
        }

        return node;
    }

    public leftOf(node: SortTreeNode): SortTreeNode {
        if (node.left) {
            node = node.left;

            while (node.right) {
                node = node.right;
            }
        } else {
            let parent: SortTreeNode;

            while ((parent = node.parent) && parent.left === node) {
                node = parent;
            }

            node = parent;
        }

        return node;
    }
    
    public first(): Point {
        const node = this.lastNode();
        return node && this.cloud.points[node.index];
    }
    
    public last(): Point {
        const node = this.lastNode();
        return node && this.cloud.points[node.index];
    }
    
    public firstNode() {
        if (!this.root) {
            return null;
        }

        let node = this.root;

        while (node.left) {
            node = node.left;
        }

        return node;
    }
    
    public lastNode() {
        if (!this.root) {
            return null;
        }

        let node = this.root;

        while (node.right) {
            node = node.right;
        }

        return node;
    }
    

    public rebuild() {
        const cloud = this.cloud;

        for (let i = 0; i < cloud.numPoints; i++) {
            const node = this.map[i];

            node.parent = null;
            node.left = null;
            node.right = null;
        }

        this.root = null;


        for (let i = 0; i < cloud.numPoints; i++) {
            const node = this.map[i];
            this.insertNode(node);
        }
    }
}

export class Dimension {
    public min = 0;
    public max = 0;
    
    public tree: SortTree;

    public constructor(
            public n: number,
            private cloud: Cloud,
            compare: DimensionCompare
    ) {

        this.tree = new SortTree(cloud, compare);
    }
    
    public update(index: number) {
        this.tree.update(index);

        this.updateMinMax();
    }
    
    public remove(index: number) {
        this.tree.remove(index);
        
        this.updateMinMax();
    }

    public updateAll() {
        this.tree.rebuild();

        this.updateMinMax();
    }

    private updateMinMax() {
        const n = this.n;

        if (this.cloud.numPoints) {
            this.min = this.tree.first()[n];
            this.max = this.tree.last()[n];
        } else {
            this.min = 0;
            this.max = 0;
        }
    }
    
    public isBounds(p: Point) {
        return this.tree.first() === p || this.tree.last() === p;
    }
    
    public range(x: number, y: number): PointWeight[] {
        const cloud = this.cloud;
        const tree = this.tree;
        const points = cloud.points;

        if (x - y === 0 || cloud.numPoints < 1) {
            return [];
        }

        const weights: PointWeight[] = [];

        const min = this.nodeLT(x);
        const max = tree.iterateRight(min, (node) => {
            const C = points[node.index];
            const Cv = C[this.n];

            // Last point
            if (Cv > y) {
                return false;
            }

            weights.push(PointWeight(C, 1));

            return true;
        });

        /*
        // We didn't enclose any point
        if (weights.length === 0) {
            const ratioA = this.interpolate(min, x);
            const ratioB = this.interpolate(min, y);

            if (min === -1) {
                weights.push(PointWeight(sorted[0], ratioA - ratioB));
            } else if (max === cloud.numPoints) {
                weights.push(PointWeight(sorted[cloud.numPoints - 1], ratioB - ratioA));
            }

            if (ratioA < 0.5) {
                if (ratioB < 0.5) {
                    weights.push(PointWeight(sorted[min], ratioB - ratioA));
                } else {
                    weights.push(PointWeight(sorted[min], 0.5 - ratioA));
                }
            }
            
            if (ratioB > 0.5) {
                if (ratioA > 0.5) {
                    weights.push(PointWeight(sorted[min], ratioB - ratioA));
                } else {
                    weights.push(PointWeight(sorted[min], ratioB - 0.5));
                }
            }

            return weights;
        }
        */

        /*
        // Interpolate between first point and the outside
        let ratio = this.interpolate(min, x);

        if (ratio >= 0.5) {
            let i = 0;
            const cmp = weights[i].P[this.n];
            for (; i < weights.length && cmp === weights[i].P[this.n]; i++) {
                weights[i].w += 0.5 - ratio;
            }
        } else if (min > -1) {
            let i = min;
            const cmp = sorted[i][this.n];
            for (; i >= 0 && cmp === sorted[i][this.n]; i--) {
                weights.push(PointWeight(sorted[i], 0.5 - ratio));
            }
        }
        
        // Interpolate between last point and the outside
        ratio = this.interpolate(max - 1, y);

        if (ratio <= 0.5) {
            let i = weights.length - 1;
            const cmp = weights[i].P[this.n];
            for (; i >= 0 && cmp === weights[i].P[this.n]; i--) {
                weights[i].w -= 0.5 - ratio;
            }
        } else if (max < cloud.numPoints) {
            let i = max;
            const cmp = sorted[i][this.n];
            for (; i < cloud.numPoints && cmp === sorted[i][this.n]; i++) {
                weights.push(PointWeight(sorted[i], ratio - 0.5));
            }
        }
        */

        return weights;
    }

    /*
    private interpolate(a: number, x: number): number {
        const sorted = this.sorted;
        const cloud = this.cloud;
        
        if (a === -1) {
            return 1 + this.interpolate(a + 1, x);
        }

        if (a + 1 == cloud.numPoints) {
            return this.interpolate(a - 1, x) - 1;
        }

        const A = sorted[a];
        const B = sorted[a + 1];

        const d = B[this.n] - A[this.n];

        // Linear interpolation
        // Using different functions yields different range selection behaviors
        return (x - A[this.n]) / d;
    }
    */

    public nodeLT(x: number): SortTreeNode {
        const points = this.cloud.points;

        return this.tree.findNode((node: SortTreeNode) => {
            const v = points[node.index][this.n];

            if (x < v) {
                return -1;
            }

            if (x > v && (!node.right || x <= points[node.right.index][this.n])) {
                return 0;
            }

            return 1;
        });
    }
}

export class Cloud {
    public points: Point[] = [];
    public numPoints = 0;

    public dims: Dimension[] = [];
    public dimensions: number = 0;

    public displacement: number;
    public readonly settings: CloudSettings;


    public constructor(settings: CloudSettings) {
        this.settings = settings;

        this.points.length = settings.maxPoints;

        this.addDimension();
    }

    public addDimension() {
        const points = this.points;

        const dim = new Dimension(this.dimensions, this, 
            this.dimensions === 1 ? fullCompare(this) : nCompare(this, this.dimensions));

        this.dims.push(dim);

        this.dimensions++;

        for (let i = 0; i < this.numPoints; i++) {
            const p = points[i];

            if (p.length < this.dimensions) {
                const n = new Float64Array(this.dimensions);
                n.set(p);
                points[i] = p;
            }
        }

        dim.updateAll();

        return this.dimensions - 1;
    }

    public getPoints(): Point[] {
        if (this.numPoints < this.points.length) {
            return this.points.slice(0, this.numPoints);
        }

        return this.points;
    }

    public add(p: Point) {
        let index = this.getAt(p);

        if (index === -1) {
            if (this.numPoints === this.points.length) {
                index = this.simplify();

                this.points[index] = p;
                
                for (const dim of this.dims) {
                    dim.update(index);
                }

                return;
            }

            index = this.numPoints++;

            this.points[index] = p;
        } else {
            this.points[index][0] += p[0];     
        } 

        for (const dim of this.dims) {
            dim.update(index);
        }
    }
    
    public getAt(X: Point): number {
        const dimensions = this.dimensions;

        if (dimensions === 1) {
            return this.numPoints - 1;
        }

        const points = this.points;

        const node = this.dims[1].tree.findNode((node) => {
            const P = points[node.index];

            for (let i2 = 1; i2 < dimensions; i2++) {
                const x = X[i2];
                const p = P[i2];
                const d = x - p;

                if (d !== 0) {
                    return d;
                }
            }

            return 0;
        });

        if (node) {
            return node.index;
        }

        return -1;
    }

    public ranges(ranges: NumberArrayLike[]) {
        const selection = new Map<Point, number>();

        for (let i = 0; i < this.dimensions; i++) {
            const rn = ranges[i];

            if (!rn) {
                continue;
            }

            const dim = this.dims[i];

            const range = new Map<Point, number>();

            for (let i2 = 0; i2 < rn.length; i2 += 2) {
                const s = dim.range(rn[i2], rn[i2 + 1]);

                if (i2 === 0) {
                    for (const {P, w} of s) {
                        range.set(P, w);
                    }
                } else {
                    for (const {P, w} of s) {
                        range.set(P, w + range.get(P));
                    }
                }
            }

            if (i === 0) {
                for (const [P, w] of range.entries()) {
                    selection.set(P, w);
                }

                continue;
            }

            for (const [P, w] of range) {
                if (!selection.has(P)) {
                    continue;
                }

                const sw = selection.get(P) * w;

                selection.set(P, sw);
            }

            for (const P of selection.keys()) {
                if (!range.has(P)) {
                    selection.delete(P);
                }
            }
        }
        
        return selection;
    }

    public point(d: Float64Array): Selection {
        const points = this.points;

        const weights = this.weights(d);

        const selection = new Map<Point, number>();

        for (let i = 0; i < this.numPoints; i++) {
            const P = points[i];
            const w = weights[i];

            selection.set(P, w);
        }
        
        return selection;
    }
 
    private simplify(): number {
        const tree = this.dims[0].tree;
        const points = this.points;
        const dimensions = this.dimensions;

        const tmp = new Float64Array(this.dimensions);

        let node = tree.firstNode();

        // worst case: O((this.dimensions * 2 + 1) * this.numPoints)
        
        while (node) {
            const P = points[node.index];

            if (this.isBounds(P)) {
                node = tree.rightOf(node);
                continue;
            }

                const a = Date.now();
            const weights = this.weights(P, P);
                console.log('simp', Date.now() - a);

            for (let i = 0; i < this.numPoints; i++) {
                const P2 = points[i];
                const V = P[0] * weights[i];

                if (V === 0) {
                    continue;
                }

                const combinedV = P2[0] + V;
                
                for (let i2 = 1; i2 < dimensions; i2++) {
                    tmp[i2] = ((P2[i2] * P2[0]) + (P[i2] * V)) / combinedV;
                }
                
                tmp[0] = combinedV;

                const swapped = this.modify(i, tmp);

                if (swapped !== -1) {
                    weights[i] = weights[swapped];
                    weights[swapped] = 0;
                    i--;
                }
            }
            
            this.displacement += P[0]; 

            return node.index;
        }

        return -1;
    }

    private modify(target: number, data: Point) {
        if (data[0] === 0) {
            return this.remove(target);
        }

        const points = this.points;
        const dims = this.dims;
        const dimensions = this.dimensions;

        const P = points[target];

        const existing = this.getAt(data);

        if (existing === -1 || existing === target) {
            for (let i = 0; i < dimensions; i++) {
                P[i] = data[i];
            }

            for (let i = 0; i < dimensions; i++) {
                dims[i].update(target);
            }

            return -1;
        }

        if (data[0] > 0) {
            points[existing][0] += data[0];
            this.dims[0].update(existing);
        }

        return this.remove(target);
    }


    private remove(target: number) {
        const points = this.points;
        const dims = this.dims;
        const dimensions = this.dimensions;

        const last = this.numPoints - 1;
        this.numPoints = last;

        if (target === last) {
            for (let i = 0; i < dimensions; i++) {
                dims[i].remove(last);
            }

            return last;
        }

        points[target] = this.points[last];


        for (let i = 0; i < dimensions; i++) {
            dims[i].remove(last);
            dims[i].update(target);
        }

        return last;
    }

    private isBounds(P: Point) {
        for (const d of this.dims) {
            if (d.isBounds(P)) {
                return true;
            }
        }
    }

    private weights(d: NumberArrayLike, exclude?: Point) {
        const points = this.points;
        const weights = new Float64Array(this.numPoints);

        let zeros = 0;
        let sum = 0;

        for (let i = 0; i < this.numPoints; i++) {
            const P = points[i];

            if (P === exclude) {
                continue;
            }

            const dist = this.distance(P, d);

            if (dist === 0) {
                zeros++;
            } else {
                const w = 1 / dist;
                weights[i] = w;
                sum += w;
            }
        }

        if (zeros) {
            const zerosInv = 1 / zeros;

            for (let i = 0; i < this.numPoints; i++) {
                if (weights[i] !== 0) {
                    weights[i] = 0;
                } else if (points[i] !== exclude) {
                    weights[i] = zerosInv;
                }
            }
        } else {
            const sumInv = 1 / sum;
            for (let i = 0; i < this.numPoints; i++) {
                weights[i] *= sumInv;
            }
        }

        return weights;
    }

    private distance(a: NumberArrayLike, b: NumberArrayLike) {
        // Simplified because we only use this
        // for relative comparisons anyways

        let dist = 0;

        for (let i = 1; i < this.dimensions; i++) {
            const d = this.dims[i];
            let rD = d.max - d.min;

            if (rD === 0) {
                continue;
            }

            const r = (a[i] - b[i]) / (d.max - d.min);

            dist += r * r;
        }

        return dist;
    }

    public stats() {
        for (const d of this.dims){
            console.log(d.tree.root);
        }
    }
}

export function scaleSelection(selection: Selection, scale: number) {
    for (const [P, w] of selection.entries()) {
        selection.set(P, w * scale);
    }
}
    
export function selectionSize(selection: Selection) {
    let v: number = 0;

    for (const [P, w] of selection.entries()) {
        v += P[0] * w;
    }

    return v;
}

export function averageSelection(selection: Selection, size: number, dimensions: number) {
    let Rd = new Float64Array(dimensions);

    for (const [P, w] of selection.entries()) {
        for (let i = 1; i < dimensions; i++) {
            Rd[i] += P[i] * P[0] * w / size;
        }
    }

    return Rd;
}
